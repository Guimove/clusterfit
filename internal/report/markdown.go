package report

import (
	"context"
	"fmt"
	"io"

	"github.com/guimove/clusterfit/internal/model"
)

// MarkdownReporter outputs recommendations as a Markdown document.
type MarkdownReporter struct {
	w io.Writer
}

func (r *MarkdownReporter) Report(_ context.Context, recs []model.Recommendation, meta ReportMeta) error {
	ew := &errWriter{w: r.w}

	ew.printf("# ClusterFit Recommendations\n\n")
	ew.printf("| Property | Value |\n")
	ew.printf("|----------|-------|\n")
	ew.printf("| Cluster | %s |\n", meta.ClusterName)
	ew.printf("| Region | %s |\n", meta.Region)
	ew.printf("| Pods | %d (+ %d DaemonSets) |\n", meta.TotalPods, meta.TotalDaemons)
	ew.printf("| Percentile | p%.0f |\n", meta.Percentile*100)
	ew.printf("| Window | %s to %s |\n",
		meta.WindowStart.Format("2006-01-02"), meta.WindowEnd.Format("2006-01-02"))
	if meta.AggregateMetrics != nil {
		am := meta.AggregateMetrics
		memGiB := am.P95MemoryBytes / (1024 * 1024 * 1024)
		ew.printf("| Cluster P95 | %.1f vCPU, %.1f GiB |\n", am.P95CPUCores, memGiB)
		ew.printf("| Node range | %d → %d (observed) |\n", am.MinNodeCount, am.MaxNodeCount)
	}
	if meta.MinNodes > 0 {
		ew.printf("| Min nodes | %d (HA constraint) |\n", meta.MinNodes)
	}
	ew.printf("\n")

	if len(recs) == 0 {
		ew.printf("No recommendations available.\n")
		return ew.err
	}

	// Recommendations table
	ew.printf("## Rankings\n\n")
	ew.printf("| Rank | Configuration | Nodes | CPU%% | Mem%% | Score | $/month |\n")
	ew.printf("|------|--------------|-------|------|------|-------|--------|\n")

	for _, rec := range recs {
		sr := rec.SimulationResult
		ew.printf("| %d | %s | %d | %.1f%% | %.1f%% | %.1f | $%.0f |\n",
			rec.Rank,
			sr.InstanceConfig.Label(),
			sr.TotalNodes,
			sr.AvgCPUUtilization*100,
			sr.AvgMemUtilization*100,
			rec.OverallScore,
			rec.MonthlyCost,
		)
	}

	// Top recommendation detail
	top := recs[0]
	topSR := top.SimulationResult
	ew.printf("\n## Top Recommendation\n\n")
	ew.printf("**%s**\n\n", topSR.InstanceConfig.Label())
	ew.printf("- Nodes: %d\n", topSR.TotalNodes)
	ew.printf("- Monthly cost: $%.0f\n", top.MonthlyCost)
	ew.printf("- CPU utilization: %.1f%%\n", topSR.AvgCPUUtilization*100)
	ew.printf("- Memory utilization: %.1f%%\n", topSR.AvgMemUtilization*100)
	ew.printf("- Resource balance: %.2f\n", topSR.Fragmentation.ResourceBalanceScore)

	if top.CostVsBaseline < 0 {
		ew.printf("- Savings vs baseline: %.1f%%\n", -top.CostVsBaseline)
	}
	if top.AnnualSavings > 0 {
		ew.printf("- Estimated annual savings: $%.0f\n", top.AnnualSavings)
	}

	if len(top.Warnings) > 0 {
		ew.printf("\n### Warnings\n\n")
		for _, w := range top.Warnings {
			ew.printf("- %s\n", w)
		}
	}

	// Workload classification and architecture alternatives
	if meta.WorkloadClass != "" {
		ew.printf("\n## Workload Profile\n\n")
		ew.printf("**%s** (%.1f GiB/vCPU)\n", meta.WorkloadClass, meta.GiBPerVCPU)
	}

	if len(meta.Alternatives) > 0 {
		ew.printf("\n## Architecture Alternatives\n\n")
		ew.printf("| Architecture | Configuration | Nodes | $/month | vs Primary |\n")
		ew.printf("|-------------|--------------|-------|---------|------------|\n")
		for _, alt := range meta.Alternatives {
			sr := alt.TopPick.SimulationResult
			savingsStr := "—"
			if alt.Savings > 0 {
				savingsStr = fmt.Sprintf("%.0f%% cheaper", alt.Savings)
			} else if alt.Savings < 0 {
				savingsStr = fmt.Sprintf("%.0f%% more expensive", -alt.Savings)
			}
			ew.printf("| %s | %s x %d | %d | $%.0f | %s |\n",
				alt.Architecture, sr.InstanceConfig.Label(), sr.TotalNodes, sr.TotalNodes, alt.TopPick.MonthlyCost, savingsStr)
		}
	}

	ew.printf("\n---\n*Generated by ClusterFit*\n")
	return ew.err
}

// errWriter wraps an io.Writer and captures the first error.
type errWriter struct {
	w   io.Writer
	err error
}

func (ew *errWriter) printf(format string, args ...any) {
	if ew.err != nil {
		return
	}
	_, ew.err = fmt.Fprintf(ew.w, format, args...)
}
